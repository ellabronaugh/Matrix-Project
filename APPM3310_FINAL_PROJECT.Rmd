---
title: "Nonorthogonal_decomposition"
author: "Ella Bronaugh"
date: "2023-11-08"
output: pdf_document
---

```{r}
library(tidyverse)
library(knitr)
library(tinytex)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(out.width = "60%")
```

# All of the below nonsense is for downloading the package that allows us to do the nonorthogonal decomposition with an included function. It's a huge package so I commented it out--don't download it if you don't have space. I haven't tried to use this function yet--I figured we could do it after we did our own decomposition to compare the results. CHANGE HERE

```{r}
#if (!require("BiocManager",quietly=TRUE))
 #   install.packages("BiocManager")
#BiocManager::install("Biobase")
```

```{r}
#browseVignettes("Biobase")
```

```{r setup, include=FALSE}
#library(BiocManager)
```

```{r setup include=FALSE}
#library(Biobase)
#install.packages("NMF")
#library(NMF)
```

# Use these packages to download the Olivetti faces dataset

```{r}
install.packages("R.matlab")
library(R.matlab)
```

```{r}
install.packages("RnavGraphImageData")
library(RnavGraphImageData)
```

```{r}
install.packages("remotes")
remotes::install_github("jlmelville/snedata")
```

```{r}
library(snedata)
```

```{r}
Olivetti <- olivetti_faces()
```

```{r}
olivetti_matrix <- do.call(rbind,Olivetti)
```

# Create a histogram of the Olivetti faces matrix in order to find the median and mean value of the values for the pixels. Use this to determine which pixels to label as 1 and which ones to label as 0. This will essentially create faces in black and white rather than grayscale.

```{r}
hist(olivetti_matrix,col="skyblue",border = "black")
abline(v=mean(olivetti_matrix),col="red",lty=2)
abline(v=median(olivetti_matrix),col="blue",lty=2)
```

# Creating a binary matrix

```{r}
binary_olivetti <- ifelse(olivetti_matrix > 135,1,0)
pattern_vector <- numeric(nrow(binary_olivetti))
presence_vector <- numeric(ncol(binary_olivetti))
```

# TEST ROW VECTOR PREDICTOR (I don't remember what this is so I commented it out and I'll deal with it later)
```{r}
#row_vector <- numeric(ncol(binary_olivetti))
#for (i in 1:ncol(binary_olivetti))
#{
 # image_row_vector[i] <- binary_olivetti[1,i]
#}
```


# Create a function for generating a pattern vector to be applied to the rows of the transposed matrix. This is created by determining how many 0's and 1's are in each column and inputting the value with the greater number of occurances in the corresponding pattern vector entry
```{r}
pattern_vector_generator <- function(matrix)
{
  ones_count <- 0
  zeros_count <- 0
  temp_pattern_vector <- numeric(nrow(matrix))
  
  for (i in 1:ncol(matrix))
  {
    for (j in 1:nrow(matrix))
    {
      if (matrix[j,i]==1)
      {
        ones_count <- ones_count + 1
      }
      else
      {
        zeros_count <- zeros_count + 1
      }
    }
    if (ones_count > zeros_count)
    {
      temp_pattern_vector[i] <- 1
    }
    else
    {
      temp_pattern_vector[i] <- 0
    }
  }
  return(temp_pattern_vector)
}
```

# Assign the pattern vector generated by the funciton to pattern_vector 
```{r}
pattern_vector <- pattern_vector_generator(binary_olivetti)
```

# Create a function to compare the values of the pattern vector with a row vector in the matrix. This will create a vector of Hamming distances by counting the number of entries in the row vector that match the value of the corresponding entry in the pattern vector. This is done for each row vector of the matrix
```{r}
hamming_distance <- function(row_vector_entry, pattern_vector_entry)
{
  hamming_distance_count = 0
  for (i in 1:length(pattern_vector_entry))
  {
    if (row_vector_entry[i]==pattern_vector_entry[i])
    {
      hamming_distance_count <- hamming_distance_count + 1
    }
  }
  return(hamming_distance_count)
}
```

#Create the Hamming_distance_vector using the funciton above
```{r}
hamming_distance_vector <- numeric(ncol(binary_olivetti))
for (i in 1:length(nrow(binary_olivetti)))
{
  temp_vector <- numeric(ncol(binary_olivetti))
  for (j in 1:length(ncol(binary_olivetti)))
  {
    temp_vector <- binary_olivetti[i,j]
  }
  hamming_distance_vector[i] <- hamming_distance(temp_vector[j],pattern_vector[j])
}
print(hamming_distance_vector)
```


# find the median of the hamming distances and then assign a 1 to the corresponding presence vector element if the hamming distance value is greater than the median
```{r}
presence_vector <- numeric(nrow(transposed_olivetti))
temp_vector <- numeric(nrow(transposed_olivetti))
```

```{r}
total_count <- 0
median <- 0
for (i in 1:length(pattern_vector))
{
  for (j in 1:length(pattern_vector))
  {
    temp_vector[j] <- transposed_olivetti[i,j]
  }
  hamming_distance_vector[i] = hamming_distance(temp_vector, pattern_vector[i])
  median <- median + hamming_distance_vector[i]
}
median <- median/nrow(hamming_distance_vector)
print(hamming_distance_vector)
```

```{r}
for (i in 1:nrow(hamming_distance_vector))
{
  if (hamming_distance_vector[i] >= median)
  {
    presence_vector[i] <- 1
  }
  else
  {
    presence_vector[i] <- 0
  }
}
print(presence_vector)
```

# Create a matrix using the presence and pattern vectors

```{r}
decomposed_matrix <- outer(presence_vector,pattern_vector,"*")
```

